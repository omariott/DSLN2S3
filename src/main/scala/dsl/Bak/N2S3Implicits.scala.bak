

import dsl.PrimitiveImplicits.Neurons
import fr.univ_lille.cristal.emeraude.n2s3.core.NeuronModel
import fr.univ_lille.cristal.emeraude.n2s3.features.builder.connection.ConnectionPolicy
import fr.univ_lille.cristal.emeraude.n2s3.features.builder.connection.types.FullConnection
import fr.univ_lille.cristal.emeraude.n2s3.models.bio.LIFNeuron

object N2S3Implicits {
  implicit class Module(identifier: String) {
    private var neuronscount = Neurons(1)
    private var neuronmodel : NeuronModel = LIFNeuron

    def having = this
    def having(neurons: Neurons) = {
      val copy = new Module(identifier: String)
      copy.neuronscount = neurons
      copy.neuronmodel = this.neuronmodel
      copy
    }

    def modeling(model: NeuronModel) = {
      val copy = new Module(identifier: String)
      copy.neuronscount = this.neuronscount
      copy.neuronmodel = model
      copy
    }

    def and (that: Module):ModulesHolder  = new ModulesHolder(Seq(this, that))

    def to(that: Module): ModulesToBeLinked ={
      new ModulesToBeLinked(this, that)
    }
  }

  class ModulesHolder(modules: Seq[Module]) {
    def and(m: Module) = new ModulesHolder(modules :+ m)
  }

  class ModulesToBeLinked(module1:Module, module2:Module){
    private var connection:ConnectionPolicy = new FullConnection

    def using(connectionType: ConnectionPolicy) = {
      val copy = new ModulesToBeLinked(module1, module2)
      copy.connection = connectionType
      copy
    }
  }
}